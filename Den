#!/usr/local/bin/lua

require "luarocks.loader"
require "ursa"

local params = ...
if type(params) ~= "table" then params = nil end -- whoops commandline input

-- Filename list for Glop core
local glop_filenames = {"Base", "Input", "GlopFrameBase", "GlopFrameStyle", "GlopWindow", "System", "Utils", "GlopInternalData", "OpenGl", "Collisions", "Font", "GlopFrameWidgets", "Image", "Thread", "Stream", "glop3d/Camera", "glop3d/Mesh", "glop3d/Point3"}
local glop_filenames_objcpp = {}

-- basic initial setup and configuration
local flags = {}
local local_os
local build_prefix

local executable_extension

local deploy_paths = {}

do
  if params and params.platform then
    ursa.token.rule{"os_name", "!" .. params.platform, function () return params.platform end}
  else
    ursa.token.rule{"os_name", nil, "uname -o || uname"}
  end
    
  local_os = ursa.token{"os_name"}

  if local_os == "Cygwin" then
    local_os = "cygwin"
    
    ursa.token.rule{"CC", nil, function () return "/cygdrive/c/MinGW/bin/g++" end}
    ursa.token.rule{"CXXFLAGS", nil, function () return "-DWIN32 -D_LIB -D_MBCS -IGlop/source -I. -g" end}
    ursa.token.rule{"LDFLAGS", nil, function () return "-lkernel32 -luser32 -lgdi32 -lwinspool -lcomdlg32 -ladvapi32 -lshell32 -lole32 -loleaut32 -luuid -lodbc32 -lodbccp32 -lopengl32 -lfreetype -ljpeg -lglu32 -ldinput -ldxguid -lfmodex -lwinmm -lpng -shared" end}
    
    ursa.token.rule{"LIBCC", nil, function () return "/cygdrive/c/MinGW/bin/gcc" end}
    ursa.token.rule{"LIBCFLAGS_BASE", nil, function () return "" end}
    ursa.token.rule{"LIBLDFLAGS_BASE", nil, function () return "" end}
    
    table.insert(glop_filenames, "OsWin32")
    table.insert(glop_filenames, "Sound")
    
    executable_extension = ".exe"
    
    deploy_paths.lib = "glop/lib/libGlop.dll"
    deploy_paths.headers = "local/include/Glop"
  elseif local_os == "Darwin" then
    local_os = "osx"
    
    ursa.token.rule{"CC", nil, function () return "g++" end}
    ursa.token.rule{"CXXFLAGS", nil, function () return "-arch i386 -DMACOSX -D_DEBUG -IGlop/source -I. -g" end}
    ursa.token.rule{"LDFLAGS", nil, function () return "-arch i386 -lfmodex -lfreetype235 -ljpeg6b -lpng -lrakneti386 -lz -F/System/Library/Frameworks -framework Carbon -framework AGL -framework OpenGL -framework ApplicationServices -framework IOKit -Wl,-single_module -compatibility_version 1 -current_version 1 -mmacosx-version-min=10.5 -headerpad_max_install_names" end}
    
    table.insert(glop_filenames, "OsMacOSX")
    table.insert(glop_filenames, "Sound")
    
    executable_extension = "app"  -- much of this needs to be redesigned
    
    deploy_paths.lib = "Glop.framework/Glop"
    deploy_paths.headers = "Glop.framework/Headers"
  elseif local_os == "iphone_sim" then
    local_os = "iphone_sim"
    
    ursa.token.rule{"CC", nil, function () return "/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin/g++" end}
    ursa.token.rule{"CXXFLAGS", nil, function () return "-D__IPHONE_OS_VERSION_MIN_REQUIRED=30000 -arch i386 -isysroot /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator3.0.sdk -mmacosx-version-min=10.5 -DIPHONE -IGlop/source" end}
    ursa.token.rule{"LDFLAGS", nil, function () return "-arch i386 -isysroot /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator3.0.sdk -mmacosx-version-min=10.5 -framework Foundation -framework UIKit -framework OpenGLES -framework QuartzCore -framework AVFoundation -ljpeg6b -lfreetype235 -lpng -lz" end}
    
    table.insert(glop_filenames_objcpp, "OsIphone")
    table.insert(glop_filenames_objcpp, "OsIphone_EAGLView")
    table.insert(glop_filenames_objcpp, "Sound_Iphone")
    
    executable_extension = "app"
    
    deploy_paths.lib = "Glop.framework/Glop"
    deploy_paths.headers = "Glop.framework/Headers"
  elseif local_os == "iphone_dev" then
    local_os = "iphone_dev"
    
    ursa.token.rule{"CC", nil, function () return "/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/gcc-4.2" end}
    ursa.token.rule{"CXXFLAGS", nil, function () return "-D__IPHONE_OS_VERSION_MIN_REQUIRED=30000 -arch armv6 -isysroot /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS3.1.2.sdk -DIPHONE -IGlop/source" end}
    ursa.token.rule{"LDFLAGS", nil, function () return "-arch armv6 -isysroot /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS3.1.2.sdk -framework Foundation -framework UIKit -framework OpenGLES -framework QuartzCore -framework AVFoundation -ljpeg6b -lfreetype235 -lpng -lz" end}
    
    table.insert(glop_filenames_objcpp, "OsIphone")
    table.insert(glop_filenames_objcpp, "OsIphone_EAGLView")
    table.insert(glop_filenames_objcpp, "Sound_Iphone")
    
    executable_extension = "app"
    
    deploy_paths.lib = "Glop.framework/Glop"
    deploy_paths.headers = "Glop.framework/Headers"
  else
    print("unknown OS", local_os)
    assert(false)
  end
  
  build_prefix = "build/" .. local_os
  release_prefix = "release/" .. local_os
end

ursa.token.rule{"LIBCFLAGS", "#LIBCFLAGS_BASE", function () return ursa.token{"LIBCFLAGS_BASE"} .. " -I../../libs_complete/include" end}
ursa.token.rule{"LIBLDFLAGS", "#LIBLDFLAGS_BASE", function () return ursa.token{"LIBLDFLAGS_BASE"} end}

-- yo dogg, who likes libraries
-- first we do zlib
local zlib = {} -- filled with everything needed to consider "zlib" to be functional
do
  local zlib_dir = "Glop/source/third_party/zlib-1.2.3"
  
  ursa.token.rule{"zlib files", nil, ("cd %s && find . -type f | sed s*\\\\./**"):format(zlib_dir)}  -- we are assuming this isn't changing
  local zlib_files = {}
  for file in ursa.token{"zlib files"}:gmatch("([^\n]+)") do
    table.insert(zlib_files, ursa.rule{build_prefix .. "/libs/zlib/" .. file, zlib_dir .. "/" .. file, ursa.util.copy{}})
  end
  
  local makefile = ursa.rule{{build_prefix .. "/libs/zlib/Makefile", build_prefix .. "/libs/zlib/zconf.h"}, zlib_files, ursa.util.system_template{('cd %s/libs/zlib && CC=#LIBCC CFLAGS="#LIBCFLAGS" LDFLAGS="#LIBLDFLAGS" ./configure'):format(build_prefix)}}
  
  local lib = ursa.rule{build_prefix .. "/libs/zlib/libz.a", {makefile, zlib_files}, ('cd %s/libs/zlib && make -j5'):format(build_prefix)}
  
  -- now we copy shit to the right place
  table.insert(zlib, ursa.rule{build_prefix .. "/libs_complete/lib/libz.a", lib, ursa.util.copy{}})
  table.insert(zlib, ursa.rule{build_prefix .. "/libs_complete/include/zlib.h", build_prefix .. "/libs/zlib/zlib.h", ursa.util.copy{}})
  table.insert(zlib, ursa.rule{build_prefix .. "/libs_complete/include/zconf.h", build_prefix .. "/libs/zlib/zconf.h", ursa.util.copy{}})
end

-- libpng next
local libpng = {} -- filled with everything needed to consider "libpng" to be functional
do
  local libpng_dir = "Glop/source/third_party/libpng-1.4.1"
  
  ursa.token.rule{"libpng files", nil, ("cd %s && find . -type f | sed s*\\\\./**"):format(libpng_dir)}  -- we are assuming this isn't changing
  local libpng_files = {}
  for file in ursa.token{"libpng files"}:gmatch("([^\n]+)") do
    table.insert(libpng_files, ursa.rule{build_prefix .. "/libs/libpng/" .. file, libpng_dir .. "/" .. file, ursa.util.copy{}})
  end
  
  local makefile = ursa.rule{{build_prefix .. "/libs/libpng/Makefile"}, {libpng_files, zlib}, ursa.util.system_template{('cd %s/libs/libpng && CC=#LIBCC CFLAGS="#LIBCFLAGS" LDFLAGS="#LIBLDFLAGS -L../../libs_complete/lib" ./configure --disable-dependency-tracking'):format(build_prefix)}}
  
  local lib = ursa.rule{build_prefix .. "/libs/libpng/libpng14.la", {makefile, libpng_files}, ('cd %s/libs/libpng && make -j5'):format(build_prefix)}
  
  -- now we copy shit to the right place
  table.insert(libpng, ursa.rule{build_prefix .. "/libs_complete/lib/libpng.la", lib, ursa.util.copy{}})
end

-- libjpeg next . . . ish
local libjpeg = {} -- filled with everything needed to consider "libjpeg" to be functional
do
  local libjpeg_dir = "Glop/source/third_party/jpeg-8a"
  
  ursa.token.rule{"libjpeg files", nil, ("cd %s && find . -type f | sed s*\\\\./**"):format(libjpeg_dir)}  -- we are assuming this isn't changing
  local libjpeg_files = {}
  for file in ursa.token{"libjpeg files"}:gmatch("([^\n]+)") do
    table.insert(libjpeg_files, ursa.rule{build_prefix .. "/libs/libjpeg/" .. file, libjpeg_dir .. "/" .. file, ursa.util.copy{}})
  end
  
  local makefile = ursa.rule{{build_prefix .. "/libs/libjpeg/Makefile"}, libjpeg_files, ursa.util.system_template{('cd %s/libs/libjpeg && CC=#LIBCC CFLAGS="#LIBCFLAGS" LDFLAGS="#LIBLDFLAGS" ./configure --disable-dependency-tracking'):format(build_prefix)}}
  
  local lib = ursa.rule{build_prefix .. "/libs/libjpeg/libjpeg.la", {makefile, libjpeg_files}, ('cd %s/libs/libjpeg && make -j5'):format(build_prefix)}
  
  -- now we copy shit to the right place
  table.insert(libjpeg, ursa.rule{build_prefix .. "/libs_complete/lib/libjpeg.la", lib, ursa.util.copy{}})
end

-- and freetype last, whatever last means
local libfreetype = {} -- filled with everything needed to consider "libfreetype" to be functional
do
  local libfreetype_dir = "Glop/source/third_party/freetype-2.3.12"
  
  ursa.token.rule{"libfreetype files", nil, ("cd %s && find . -type f | sed s*\\\\./**"):format(libfreetype_dir)}  -- we are assuming this isn't changing
  local libfreetype_files = {}
  for file in ursa.token{"libfreetype files"}:gmatch("([^\n]+)") do
    if file == "builds/unix/unix-def.in" then
      table.insert(libfreetype_files, ursa.rule{build_prefix .. "/libs/libfreetype/" .. file, libfreetype_dir .. "/" .. file, ursa.util.system_template{'sed "s/TOP_DIR := .*/TOP_DIR := ./" $SOURCE > $TARGET'}})
    else
      table.insert(libfreetype_files, ursa.rule{build_prefix .. "/libs/libfreetype/" .. file, libfreetype_dir .. "/" .. file, ursa.util.copy{}})
    end
  end
  
  local makefile = ursa.rule{{build_prefix .. "/libs/libfreetype/builds/unix/freetype-config"}, libfreetype_files, ursa.util.system_template{('cd %s/libs/libfreetype && CC=#LIBCC CFLAGS="#LIBCFLAGS" LDFLAGS="#LIBLDFLAGS" ./configure'):format(build_prefix)}}
  
  local lib = ursa.rule{build_prefix .. "/libs/libfreetype/objs/libfreetype.la", {makefile, libfreetype_files}, ('cd %s/libs/libfreetype && make -j5'):format(build_prefix)}
  
  -- now we copy shit to the right place
  table.insert(libfreetype, ursa.rule{build_prefix .. "/libs_complete/lib/libfreetype.la", lib, ursa.util.copy{}})
end

ursa.token.rule{"testtesttest", {zlib, libpng, libjpeg, libfreetype}, function () return "" end}

-- parse the result from g++'s built-in dependency scanner
local function make_dependencies(srcfile)
  local deps = ursa.util.system{("%s %s -MM %s"):format(ursa.token{"CC"}, ursa.token{"CXXFLAGS"}, srcfile)}
  deps = deps:match("^.*: (.*)$")
  
  local dependencies = {}
  for file in deps:gmatch("([^%s]+)") do
    if file ~= "\\" then
      table.insert(dependencies, file)
    end
  end
  
  return dependencies
end

-- build the source files
local objects = {}
for _, file in ipairs(glop_filenames) do
  local cpp = "Glop/source/" .. file .. ".cpp"
  local o = "build/Glop/" .. file .. ".o"
  local depend = "Glop/" .. file .. " dependencies"
  
  ursa.token.rule{depend, ursa.util.token_deferred{depend, default = cpp}, function () return make_dependencies(cpp) end}
  table.insert(objects, ursa.rule{o, ursa.util.token_deferred{depend}, ursa.util.system_template{("#CC -O2 #CXXFLAGS -o %s -c %s"):format(o, cpp)}})
end
for _, file in ipairs(glop_filenames_objcpp) do
  local cpp = "Glop/source/" .. file .. ".mm"
  local o = "build/Glop/" .. file .. ".o"
  local depend = "Glop/" .. file .. " dependencies"
  
  ursa.token.rule{depend, ursa.util.token_deferred{depend, default = cpp}, function () return make_dependencies(cpp) end}
  table.insert(objects, ursa.rule{o, ursa.util.token_deferred{depend}, ursa.util.system_template{("#CC -O2 #CXXFLAGS -o %s -c %s"):format(o, cpp)}})
end

local lib = nil
local headers = {}

-- build the glop library
lib = ursa.rule{"build/Glop/" .. deploy_paths.lib, objects, ursa.util.system_template{"#CC -O2 -o $TARGET $SOURCES #LDFLAGS"}}

-- mirror source files into the appropriate build directory
ursa.token.rule{"headers", nil, "cd Glop/source && find . -type f | sed s*\\\\./** | grep \\.h$"}
for k in ursa.token{"headers"}:gmatch("[^%s]+") do
  table.insert(headers, ursa.rule{"build/Glop/" .. deploy_paths.headers .. "/" .. k, "Glop/source/" .. k, ursa.util.system_template{"cp $SOURCE $TARGET"}})
end

ursa.command{"glop", {lib, headers}}



-- let's have some actual apps
local applist = {}
local function BuildApp(appname, files)
  local objects = {}
  for _, file in ipairs(files) do
    local cpp = ("%s/%s.cpp"):format(appname, file)
    local o = ("build/%s/%s.o"):format(appname, file)
    local depend = ("%s/%s dependencies"):format(appname, file)
    
    ursa.token.rule{depend, {headers, ursa.util.token_deferred{depend, default = cpp}}, function () return make_dependencies(cpp) end}
    table.insert(objects, ursa.rule{o, {headers, ursa.util.token_deferred{depend}}, ursa.util.system_template{("#CC -O2 #CXXFLAGS -o %s -c %s"):format(o, cpp)}})
  end
  
  local out = "build/" .. appname .. executable_extension
  table.insert(applist, ursa.rule{out, {objects, lib}, ursa.util.system_template{"#CC -O2 -o $TARGET $SOURCES #LDFLAGS"}})
end

BuildApp("Tests", {"Tests"})

ursa.command{ursa.command.default, applist}

-- clean things up properly

if not clean_dirs then clean_dirs = {} end
table.insert(clean_dirs, "build/Glop/glop3d")
table.insert(clean_dirs, "build/Glop")
table.insert(clean_dirs, "build/Tests")
table.insert(clean_dirs, "build")

ursa.command{"clean", function ()
  ursa.util.clean()
  for _, v in ipairs(clean_dirs) do
    os.remove(v)
  end
end}

ursa.build{...}


return {lib = lib, headers = headers, os = local_os, cc = ursa.token{"CC"}} -- just in case we're being shelled by something, here's the glop package data
